{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"moment\"));else if (typeof define === 'function' && define.amd) define(\"moment-range\", [\"moment\"], factory);else if (typeof exports === 'object') exports[\"moment-range\"] = factory(require(\"moment\"));else root[\"moment-range\"] = factory(root[\"moment\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_2__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // identity function for calling harmony imports with the correct context\n\n      /******/\n\n      __webpack_require__.i = function (value) {\n        return value;\n      };\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 3);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _undefined = __webpack_require__(5)(); // Support ES3 engines\n\n\n      module.exports = function (val) {\n        return val !== _undefined && val !== null;\n      };\n      /***/\n\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = __webpack_require__(18)() ? Symbol : __webpack_require__(20);\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.DateRange = undefined;\n\n      var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n\n          try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n\n              if (i && _arr.length === i) break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"]) _i[\"return\"]();\n            } finally {\n              if (_d) throw _e;\n            }\n          }\n\n          return _arr;\n        }\n\n        return function (arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n\n      var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n        return typeof obj;\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      exports.extendMoment = extendMoment;\n\n      var _moment = __webpack_require__(2);\n\n      var _moment2 = _interopRequireDefault(_moment);\n\n      var _es6Symbol = __webpack_require__(1);\n\n      var _es6Symbol2 = _interopRequireDefault(_es6Symbol);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      } //-----------------------------------------------------------------------------\n      // Constants\n      //-----------------------------------------------------------------------------\n\n\n      var INTERVALS = {\n        year: true,\n        quarter: true,\n        month: true,\n        week: true,\n        day: true,\n        hour: true,\n        minute: true,\n        second: true\n      }; //-----------------------------------------------------------------------------\n      // Date Ranges\n      //-----------------------------------------------------------------------------\n\n      var DateRange = exports.DateRange = function () {\n        function DateRange(start, end) {\n          _classCallCheck(this, DateRange);\n\n          var s = start;\n          var e = end;\n\n          if (arguments.length === 1 || end === undefined) {\n            if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object' && start.length === 2) {\n              var _start = _slicedToArray(start, 2);\n\n              s = _start[0];\n              e = _start[1];\n            } else if (typeof start === 'string') {\n              var _isoSplit = isoSplit(start);\n\n              var _isoSplit2 = _slicedToArray(_isoSplit, 2);\n\n              s = _isoSplit2[0];\n              e = _isoSplit2[1];\n            }\n          }\n\n          this.start = s || s === 0 ? (0, _moment2.default)(s) : (0, _moment2.default)(-8640000000000000);\n          this.end = e || e === 0 ? (0, _moment2.default)(e) : (0, _moment2.default)(8640000000000000);\n        }\n\n        _createClass(DateRange, [{\n          key: 'adjacent',\n          value: function adjacent(other) {\n            var sameStartEnd = this.start.isSame(other.end);\n            var sameEndStart = this.end.isSame(other.start);\n            return sameStartEnd && other.start.valueOf() <= this.start.valueOf() || sameEndStart && other.end.valueOf() >= this.end.valueOf();\n          }\n        }, {\n          key: 'add',\n          value: function add(other) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              adjacent: false\n            };\n\n            if (this.overlaps(other, options)) {\n              return new this.constructor(_moment2.default.min(this.start, other.start), _moment2.default.max(this.end, other.end));\n            }\n\n            return null;\n          }\n        }, {\n          key: 'by',\n          value: function by(interval) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              exclusive: false,\n              step: 1\n            };\n            var range = this;\n            return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n              var exclusive = options.exclusive || false;\n              var step = options.step || 1;\n              var diff = Math.abs(range.start.diff(range.end, interval)) / step;\n              var iteration = 0;\n              return {\n                next: function next() {\n                  var current = range.start.clone().add(iteration * step, interval);\n                  var done = exclusive ? !(iteration < diff) : !(iteration <= diff);\n                  iteration++;\n                  return {\n                    done: done,\n                    value: done ? undefined : current\n                  };\n                }\n              };\n            });\n          }\n        }, {\n          key: 'byRange',\n          value: function byRange(interval) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              exclusive: false,\n              step: 1\n            };\n            var range = this;\n            var step = options.step || 1;\n            var diff = this.valueOf() / interval.valueOf() / step;\n            var exclusive = options.exclusive || false;\n            var unit = Math.floor(diff);\n            var iteration = 0;\n            return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n              if (unit === Infinity) {\n                return {\n                  done: true\n                };\n              }\n\n              return {\n                next: function next() {\n                  var current = (0, _moment2.default)(range.start.valueOf() + interval.valueOf() * iteration * step);\n                  var done = unit === diff && exclusive ? !(iteration < unit) : !(iteration <= unit);\n                  iteration++;\n                  return {\n                    done: done,\n                    value: done ? undefined : current\n                  };\n                }\n              };\n            });\n          }\n        }, {\n          key: 'center',\n          value: function center() {\n            var center = this.start.valueOf() + this.diff() / 2;\n            return (0, _moment2.default)(center);\n          }\n        }, {\n          key: 'clone',\n          value: function clone() {\n            return new this.constructor(this.start, this.end);\n          }\n        }, {\n          key: 'contains',\n          value: function contains(other) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              exclusive: false\n            };\n            var start = this.start.valueOf();\n            var end = this.end.valueOf();\n            var oStart = other.valueOf();\n            var oEnd = other.valueOf();\n\n            if (other instanceof DateRange) {\n              oStart = other.start.valueOf();\n              oEnd = other.end.valueOf();\n            }\n\n            var startInRange = start < oStart || start <= oStart && !options.exclusive;\n            var endInRange = end > oEnd || end >= oEnd && !options.exclusive;\n            return startInRange && endInRange;\n          }\n        }, {\n          key: 'diff',\n          value: function diff(unit, rounded) {\n            return this.end.diff(this.start, unit, rounded);\n          }\n        }, {\n          key: 'duration',\n          value: function duration(unit, rounded) {\n            return this.diff(unit, rounded);\n          }\n        }, {\n          key: 'intersect',\n          value: function intersect(other) {\n            var start = this.start.valueOf();\n            var end = this.end.valueOf();\n            var otherStart = other.start.valueOf();\n            var otherEnd = other.end.valueOf();\n            var isZeroLength = start == end;\n            var isOtherZeroLength = otherStart == otherEnd; // Zero-length ranges\n\n            if (isZeroLength) {\n              var point = start;\n\n              if (point == otherStart || point == otherEnd) {\n                return null;\n              } else if (point > otherStart && point < otherEnd) {\n                return this;\n              }\n            } else if (isOtherZeroLength) {\n              var _point = otherStart;\n\n              if (_point == start || _point == end) {\n                return null;\n              } else if (_point > start && _point < end) {\n                return other;\n              }\n            } // Non zero-length ranges\n\n\n            if (start <= otherStart && otherStart < end && end < otherEnd) {\n              return new this.constructor(otherStart, end);\n            } else if (otherStart < start && start < otherEnd && otherEnd <= end) {\n              return new this.constructor(start, otherEnd);\n            } else if (otherStart < start && start <= end && end < otherEnd) {\n              return this;\n            } else if (start <= otherStart && otherStart <= otherEnd && otherEnd <= end) {\n              return other;\n            }\n\n            return null;\n          }\n        }, {\n          key: 'isEqual',\n          value: function isEqual(other) {\n            return this.start.isSame(other.start) && this.end.isSame(other.end);\n          }\n        }, {\n          key: 'isSame',\n          value: function isSame(other) {\n            return this.isEqual(other);\n          }\n        }, {\n          key: 'overlaps',\n          value: function overlaps(other) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              adjacent: false\n            };\n            var intersect = this.intersect(other) !== null;\n\n            if (options.adjacent && !intersect) {\n              return this.adjacent(other);\n            }\n\n            return intersect;\n          }\n        }, {\n          key: 'reverseBy',\n          value: function reverseBy(interval) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              exclusive: false,\n              step: 1\n            };\n            var range = this;\n            return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n              var exclusive = options.exclusive || false;\n              var step = options.step || 1;\n              var diff = Math.abs(range.start.diff(range.end, interval)) / step;\n              var iteration = 0;\n              return {\n                next: function next() {\n                  var current = range.end.clone().subtract(iteration * step, interval);\n                  var done = exclusive ? !(iteration < diff) : !(iteration <= diff);\n                  iteration++;\n                  return {\n                    done: done,\n                    value: done ? undefined : current\n                  };\n                }\n              };\n            });\n          }\n        }, {\n          key: 'reverseByRange',\n          value: function reverseByRange(interval) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n              exclusive: false,\n              step: 1\n            };\n            var range = this;\n            var step = options.step || 1;\n            var diff = this.valueOf() / interval.valueOf() / step;\n            var exclusive = options.exclusive || false;\n            var unit = Math.floor(diff);\n            var iteration = 0;\n            return _defineProperty({}, _es6Symbol2.default.iterator, function () {\n              if (unit === Infinity) {\n                return {\n                  done: true\n                };\n              }\n\n              return {\n                next: function next() {\n                  var current = (0, _moment2.default)(range.end.valueOf() - interval.valueOf() * iteration * step);\n                  var done = unit === diff && exclusive ? !(iteration < unit) : !(iteration <= unit);\n                  iteration++;\n                  return {\n                    done: done,\n                    value: done ? undefined : current\n                  };\n                }\n              };\n            });\n          }\n        }, {\n          key: 'subtract',\n          value: function subtract(other) {\n            var start = this.start.valueOf();\n            var end = this.end.valueOf();\n            var oStart = other.start.valueOf();\n            var oEnd = other.end.valueOf();\n\n            if (this.intersect(other) === null) {\n              return [this];\n            } else if (oStart <= start && start < end && end <= oEnd) {\n              return [];\n            } else if (oStart <= start && start < oEnd && oEnd < end) {\n              return [new this.constructor(oEnd, end)];\n            } else if (start < oStart && oStart < end && end <= oEnd) {\n              return [new this.constructor(start, oStart)];\n            } else if (start < oStart && oStart < oEnd && oEnd < end) {\n              return [new this.constructor(start, oStart), new this.constructor(oEnd, end)];\n            } else if (start < oStart && oStart < end && oEnd < end) {\n              return [new this.constructor(start, oStart), new this.constructor(oStart, end)];\n            }\n\n            return [];\n          }\n        }, {\n          key: 'toDate',\n          value: function toDate() {\n            return [this.start.toDate(), this.end.toDate()];\n          }\n        }, {\n          key: 'toString',\n          value: function toString() {\n            return this.start.format() + '/' + this.end.format();\n          }\n        }, {\n          key: 'valueOf',\n          value: function valueOf() {\n            return this.end.valueOf() - this.start.valueOf();\n          }\n        }]);\n\n        return DateRange;\n      }(); //-----------------------------------------------------------------------------\n      // Moment Extensions\n      //-----------------------------------------------------------------------------\n\n\n      function extendMoment(moment) {\n        /**\n         * Build a date range.\n         */\n        moment.range = function range(start, end) {\n          var m = this;\n\n          if (INTERVALS.hasOwnProperty(start)) {\n            return new DateRange(moment(m).startOf(start), moment(m).endOf(start));\n          }\n\n          return new DateRange(start, end);\n        };\n        /**\n         * Build a date range between a date (or now) and a specified interval.\n         * @param {String} interval The type of interval\n         * @param {Number} [count=1] The number of intervals (positive or negative)\n         * @param {Moment|Date} [date=moment()] The date to use\n         * @return {DateRange}\n         */\n\n\n        moment.rangeFromInterval = function (interval) {\n          var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n          var date = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : moment();\n          if (!moment.isMoment(date)) date = moment(date);\n          if (!date.isValid()) throw new Error('Invalid date.');\n          var dateWithInterval = date.clone().add(count, interval); // Handle negative interval counts by assembling the dates in chronological order.\n\n          var dates = [];\n          dates.push(moment.min(date, dateWithInterval));\n          dates.push(moment.max(date, dateWithInterval));\n          return new DateRange(dates);\n        };\n        /**\n         * Uses moment.parseZone on both the start and end of the given time interval\n         * to preserve the time zones on the resulting DateRange object.\n         * @param {string} isoTimeInterval the timeInterval to be parsed\n         * @return {DateRange} constructed using moments that will preserve the time zones\n         */\n\n\n        moment.parseZoneRange = function (isoTimeInterval) {\n          var momentStrings = isoSplit(isoTimeInterval);\n          var start = moment.parseZone(momentStrings[0]);\n          var end = moment.parseZone(momentStrings[1]);\n          return new DateRange(start, end);\n        };\n        /**\n         * Alias of static constructor.\n         */\n\n\n        moment.fn.range = moment.range;\n        /**\n         * Expose constructor\n         */\n\n        moment.range.constructor = DateRange;\n        /**\n         * Check if the current object is a date range.\n         */\n\n        moment.isRange = function (range) {\n          return range instanceof DateRange;\n        };\n        /**\n         * Check if the current moment is within a given date range.\n         */\n\n\n        moment.fn.within = function (range) {\n          return range.contains(this.toDate());\n        };\n\n        return moment;\n      } //-----------------------------------------------------------------------------\n      // Utility Functions\n      //-----------------------------------------------------------------------------\n\n      /**\n       * Splits an iso string into two strings.\n       */\n\n\n      function isoSplit(isoString) {\n        return isoString.split('/');\n      }\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var assign = __webpack_require__(6),\n          normalizeOpts = __webpack_require__(13),\n          isCallable = __webpack_require__(9),\n          contains = __webpack_require__(15),\n          d;\n\n      d = module.exports = function (dscr, value\n      /*, options*/\n      ) {\n        var c, e, w, options, desc;\n\n        if (arguments.length < 2 || typeof dscr !== 'string') {\n          options = value;\n          value = dscr;\n          dscr = null;\n        } else {\n          options = arguments[2];\n        }\n\n        if (dscr == null) {\n          c = w = true;\n          e = false;\n        } else {\n          c = contains.call(dscr, 'c');\n          e = contains.call(dscr, 'e');\n          w = contains.call(dscr, 'w');\n        }\n\n        desc = {\n          value: value,\n          configurable: c,\n          enumerable: e,\n          writable: w\n        };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n\n      d.gs = function (dscr, get, set\n      /*, options*/\n      ) {\n        var c, e, options, desc;\n\n        if (typeof dscr !== 'string') {\n          options = set;\n          set = get;\n          get = dscr;\n          dscr = null;\n        } else {\n          options = arguments[3];\n        }\n\n        if (get == null) {\n          get = undefined;\n        } else if (!isCallable(get)) {\n          options = get;\n          get = set = undefined;\n        } else if (set == null) {\n          set = undefined;\n        } else if (!isCallable(set)) {\n          options = set;\n          set = undefined;\n        }\n\n        if (dscr == null) {\n          c = true;\n          e = false;\n        } else {\n          c = contains.call(dscr, 'c');\n          e = contains.call(dscr, 'e');\n        }\n\n        desc = {\n          get: get,\n          set: set,\n          configurable: c,\n          enumerable: e\n        };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n      /***/\n\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // eslint-disable-next-line no-empty-function\n\n      module.exports = function () {};\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = __webpack_require__(7)() ? Object.assign : __webpack_require__(8);\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = function () {\n        var assign = Object.assign,\n            obj;\n        if (typeof assign !== \"function\") return false;\n        obj = {\n          foo: \"raz\"\n        };\n        assign(obj, {\n          bar: \"dwa\"\n        }, {\n          trzy: \"trzy\"\n        });\n        return obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n      };\n      /***/\n\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var keys = __webpack_require__(10),\n          value = __webpack_require__(14),\n          max = Math.max;\n\n      module.exports = function (dest, src\n      /*, …srcn*/\n      ) {\n        var error,\n            i,\n            length = max(arguments.length, 2),\n            assign;\n        dest = Object(value(dest));\n\n        assign = function assign(key) {\n          try {\n            dest[key] = src[key];\n          } catch (e) {\n            if (!error) error = e;\n          }\n        };\n\n        for (i = 1; i < length; ++i) {\n          src = arguments[i];\n          keys(src).forEach(assign);\n        }\n\n        if (error !== undefined) throw error;\n        return dest;\n      };\n      /***/\n\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // Deprecated\n\n      module.exports = function (obj) {\n        return typeof obj === \"function\";\n      };\n      /***/\n\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = __webpack_require__(11)() ? Object.keys : __webpack_require__(12);\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = function () {\n        try {\n          Object.keys(\"primitive\");\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n      /***/\n\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var isValue = __webpack_require__(0);\n\n      var keys = Object.keys;\n\n      module.exports = function (object) {\n        return keys(isValue(object) ? Object(object) : object);\n      };\n      /***/\n\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var isValue = __webpack_require__(0);\n\n      var forEach = Array.prototype.forEach,\n          create = Object.create;\n\n      var process = function process(src, obj) {\n        var key;\n\n        for (key in src) {\n          obj[key] = src[key];\n        }\n      }; // eslint-disable-next-line no-unused-vars\n\n\n      module.exports = function (opts1\n      /*, …options*/\n      ) {\n        var result = create(null);\n        forEach.call(arguments, function (options) {\n          if (!isValue(options)) return;\n          process(Object(options), result);\n        });\n        return result;\n      };\n      /***/\n\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var isValue = __webpack_require__(0);\n\n      module.exports = function (value) {\n        if (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n        return value;\n      };\n      /***/\n\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = __webpack_require__(16)() ? String.prototype.contains : __webpack_require__(17);\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var str = \"razdwatrzy\";\n\n      module.exports = function () {\n        if (typeof str.contains !== \"function\") return false;\n        return str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n      };\n      /***/\n\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var indexOf = String.prototype.indexOf;\n\n      module.exports = function (searchString\n      /*, position*/\n      ) {\n        return indexOf.call(this, searchString, arguments[1]) > -1;\n      };\n      /***/\n\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var validTypes = {\n        object: true,\n        symbol: true\n      };\n\n      module.exports = function () {\n        var symbol;\n        if (typeof Symbol !== 'function') return false;\n        symbol = Symbol('test symbol');\n\n        try {\n          String(symbol);\n        } catch (e) {\n          return false;\n        } // Return 'true' also for polyfills\n\n\n        if (!validTypes[typeof Symbol.iterator]) return false;\n        if (!validTypes[typeof Symbol.toPrimitive]) return false;\n        if (!validTypes[typeof Symbol.toStringTag]) return false;\n        return true;\n      };\n      /***/\n\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = function (x) {\n        if (!x) return false;\n        if (typeof x === 'symbol') return true;\n        if (!x.constructor) return false;\n        if (x.constructor.name !== 'Symbol') return false;\n        return x[x.constructor.toStringTag] === 'Symbol';\n      };\n      /***/\n\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n      var d = __webpack_require__(4),\n          validateSymbol = __webpack_require__(21),\n          create = Object.create,\n          defineProperties = Object.defineProperties,\n          defineProperty = Object.defineProperty,\n          objPrototype = Object.prototype,\n          NativeSymbol,\n          SymbolPolyfill,\n          HiddenSymbol,\n          globalSymbols = create(null),\n          isNativeSafe;\n\n      if (typeof Symbol === 'function') {\n        NativeSymbol = Symbol;\n\n        try {\n          String(NativeSymbol());\n          isNativeSafe = true;\n        } catch (ignore) {}\n      }\n\n      var generateName = function () {\n        var created = create(null);\n        return function (desc) {\n          var postfix = 0,\n              name,\n              ie11BugWorkaround;\n\n          while (created[desc + (postfix || '')]) {\n            ++postfix;\n          }\n\n          desc += postfix || '';\n          created[desc] = true;\n          name = '@@' + desc;\n          defineProperty(objPrototype, name, d.gs(null, function (value) {\n            // For IE11 issue see:\n            // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n            //    ie11-broken-getters-on-dom-objects\n            // https://github.com/medikoo/es6-symbol/issues/12\n            if (ie11BugWorkaround) return;\n            ie11BugWorkaround = true;\n            defineProperty(this, name, d(value));\n            ie11BugWorkaround = false;\n          }));\n          return name;\n        };\n      }(); // Internal constructor (not one exposed) for creating Symbol instances.\n      // This one is used to ensure that `someSymbol instanceof Symbol` always return false\n\n\n      HiddenSymbol = function Symbol(description) {\n        if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');\n        return SymbolPolyfill(description);\n      }; // Exposed `Symbol` constructor\n      // (returns instances of HiddenSymbol)\n\n\n      module.exports = SymbolPolyfill = function Symbol(description) {\n        var symbol;\n        if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');\n        if (isNativeSafe) return NativeSymbol(description);\n        symbol = create(HiddenSymbol.prototype);\n        description = description === undefined ? '' : String(description);\n        return defineProperties(symbol, {\n          __description__: d('', description),\n          __name__: d('', generateName(description))\n        });\n      };\n\n      defineProperties(SymbolPolyfill, {\n        for: d(function (key) {\n          if (globalSymbols[key]) return globalSymbols[key];\n          return globalSymbols[key] = SymbolPolyfill(String(key));\n        }),\n        keyFor: d(function (s) {\n          var key;\n          validateSymbol(s);\n\n          for (key in globalSymbols) {\n            if (globalSymbols[key] === s) return key;\n          }\n        }),\n        // To ensure proper interoperability with other native functions (e.g. Array.from)\n        // fallback to eventual native implementation of given symbol\n        hasInstance: d('', NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill('hasInstance')),\n        isConcatSpreadable: d('', NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill('isConcatSpreadable')),\n        iterator: d('', NativeSymbol && NativeSymbol.iterator || SymbolPolyfill('iterator')),\n        match: d('', NativeSymbol && NativeSymbol.match || SymbolPolyfill('match')),\n        replace: d('', NativeSymbol && NativeSymbol.replace || SymbolPolyfill('replace')),\n        search: d('', NativeSymbol && NativeSymbol.search || SymbolPolyfill('search')),\n        species: d('', NativeSymbol && NativeSymbol.species || SymbolPolyfill('species')),\n        split: d('', NativeSymbol && NativeSymbol.split || SymbolPolyfill('split')),\n        toPrimitive: d('', NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill('toPrimitive')),\n        toStringTag: d('', NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill('toStringTag')),\n        unscopables: d('', NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill('unscopables'))\n      }); // Internal tweaks for real symbol producer\n\n      defineProperties(HiddenSymbol.prototype, {\n        constructor: d(SymbolPolyfill),\n        toString: d('', function () {\n          return this.__name__;\n        })\n      }); // Proper implementation of methods exposed on Symbol.prototype\n      // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\n\n      defineProperties(SymbolPolyfill.prototype, {\n        toString: d(function () {\n          return 'Symbol (' + validateSymbol(this).__description__ + ')';\n        }),\n        valueOf: d(function () {\n          return validateSymbol(this);\n        })\n      });\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {\n        var symbol = validateSymbol(this);\n        if (typeof symbol === 'symbol') return symbol;\n        return symbol.toString();\n      }));\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol')); // Proper implementaton of toPrimitive and toStringTag for returned symbol instances\n\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])); // Note: It's important to define `toPrimitive` as last one, as some implementations\n      // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n      // And that may invoke error in definition flow:\n      // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\n\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var isSymbol = __webpack_require__(19);\n\n      module.exports = function (value) {\n        if (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n        return value;\n      };\n      /***/\n\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}